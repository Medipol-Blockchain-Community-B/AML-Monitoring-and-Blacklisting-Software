{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(history.state, \"\", urlToPush) : history.replaceState(history.state, \"\", urlToPush);\n};\n\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\n\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\n\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\n\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n\n  return {\n    offsetTop: offsetTop,\n    offsetParent: currentOffsetParent\n  };\n};\n\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    } // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n            offsetTop = _getElementOffsetInfo.offsetTop,\n            offsetParent = _getElementOffsetInfo.offsetParent;\n\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n\n        return offsetTop;\n      }\n\n      return t.offsetTop;\n    }\n\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\n\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","updateHash","hash","historyUpdate","hashVal","indexOf","substring","hashToUpdate","curLoc","window","location","urlToPush","pathname","search","history","pushState","state","replaceState","getHash","replace","filterElementInContainer","container","element","contains","compareDocumentPosition","isPositioned","getComputedStyle","position","getElementOffsetInfoUntil","predicate","offsetTop","currentOffsetParent","offsetParent","scrollOffset","c","t","horizontal","document","getBoundingClientRect","left","scrollX","pageXOffset","offsetLeft","top","scrollY","pageYOffset","isContainerElementOrDocument","e","_getElementOffsetInfo","Error","isDocument","default"],"sources":["/Users/burakkaratas/first-try/node_modules/react-scroll/modules/mixins/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(history.state, \"\", urlToPush) : history.replaceState(history.state, \"\", urlToPush);\n};\n\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\n\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\n\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\n\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n\n  return { offsetTop: offsetTop, offsetParent: currentOffsetParent };\n};\n\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    }\n\n    // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n            offsetTop = _getElementOffsetInfo.offsetTop,\n            offsetParent = _getElementOffsetInfo.offsetParent;\n\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n\n        return offsetTop;\n      }\n\n      return t.offsetTop;\n    }\n\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\n\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}